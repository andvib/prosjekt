\section{ACADO toolkit}

The ACADO Toolkit \cite{acadoHOUSKA} is an open-source toolkit that supports several different methods for solving optimization problems. The toolkit provides methods to solve four different classes of optimization problem: Optimal control problems, multi-objective optimization and optimal control problems, parameter and state estimation problems, and model predictive control. Even though the toolkit will be used to create an MPC in this case, the optimal control problems (OCP) class will be used instead. The reason for this is that between each iteration of the MPC algorithm a new trajectory must be generated, and the MPC problem class does not have the functionality needed to do this. How the trajectory is calculated and how it is passed to the toolkit will be explained later in this chapter.

%To solve the optimization problems the toolkit uses many different algorithms. It also has its own Runge-Kutta and BDF integrators to simulate both ODE's (Ordinary Differential Equation) and DAE's (Differential Algebraic Equation). A MATLAB interface is also supplied by the toolkit, but this will not be used for this thesis.


\subsection{Discretization (Workin' Title)}

The model and optimization problem will be written on continuous time form, which means that it has to be discretized in order to be solved. The method used to discretisize the problem plays a big role in how the problem is solved, and ACADO uses the \textit{direct multiple-shooting} method. Direct discretization methods can be explained as "first discretize, then optimize", which allows for easier treatment of inequality constraints \cite{discDIEHL}. One of the major benefits by using the direct multiple-shooting method is that the method is initialized with the result from the previous iteration \cite{stallMATHISEN}.

In short the direct multiple-shooting method starts by computing a discretized control trajectory for a finite time interval. Independently, the Ordinary Differential Equations (ODE) of the optimization problem is solved one time for every timestep of the discretized control trajectory. Simultaneously as these solutions are computed an integral of a cost function is computed, which is the reason why the direct multiple-shooting method is also called a \textit{simultaneous} method. 

\begin{equation}
\label{eq:multiple_shooting}
	\begin{array}{rrlcl}
	\displaystyle \min_{\mathbf{s},\mathbf{q}} & \multicolumn{3}{l}{\sum_{i=0}^{N-1} F_i(\mathbf{s}_i, \mathbf{q}_i)+ E(\mathbf{s}_N)} \\
	\textrm{s.t}
	& \mathbf{x}_0 - \mathbf{s}_0 & = 0 & \\
	& \mathbf{x}_i(t_{i+1};\mathbf{s}_i,\mathbf{q}_i)-\mathbf{s}_{i+1} & = 0,& \hspace{5pt} i = 0,...,N-1 \\
	& h(\mathbf{s}_i, \mathbf{q}_i) & \leq 0,& \hspace{5pt} i = 0,...,N
	\end{array}
\end{equation}

The direct multiple-shooting method can be described by the nonlinear program (NLP) shown in equation \ref{eq:multiple_shooting} \cite{stallMATHISEN}. In the equation the objective function $F$ is the result of integrating the cost function, and $\mathbf{s}$ and $\mathbf{q}$ are the optimization variables for the states and controls respectively. $\mathbf{s}$ and $\mathbf{q}$ are introduced in order to ensure that the solution for the time interval is tied to the initial values. $E$ is the end term of the objective funtion.


\subsection{Runge-Kutta Method}

The Runge-Kutta method is a form of \textit{numerical integrator} that can be used to solve differential equations, and is used by the ACADO toolkit to integrate the prediction model. The method is based on the Euler method, which is a very simple method for numerical integration.

The ACADO toolkit provides algorithms for \textit{explicit} Runge-Kutta methods \cite{acadoHOUSKA}, where explicit means that the method calculates the state of the system at a later time based on the current state (THIS NEEDS SOURCE). The Runge-Kutta method calculates the later state of the system by calculating several approximations of the derivative of the system. The current state of the system together with a linear combination of the approximated derivatives gives the next state of the system \cite{modsimEGELAND}. For a system on the form $\mathbf{\dot{y}} = \mathbf{f}(\mathbf{y},t)$, the Runge-Kutta method can be mathematically expressed as:

\begin{subequations}
\begin{equation}
	\mathbf{k}_i = \mathbf{f}(\mathbf{y}_n + h \sum_{j=1}^{i-1} a_{ij}\mathbf{k}_j, t_n + c_ih), i = 1, ..., \sigma
\end{equation}
\begin{equation}
	\mathbf{y}_{n+1} = \mathbf{y}_n + h \sum_{j=1}^\sigma b_j \mathbf{k}_j
\end{equation}
\end{subequations}

where $t_n$ is the current time, $\mathbf{y}_n$ is the output of the system at the current time, $h$ is the step size and $\sigma$ is the number of approximations of the derivative that is calculated. $a$, $b$ and $c$ are parameters for the specific Runge-Kutta method used, and $c$ must satisfy $0 < c < 1$.

\subsection{Solver}

In order to solve the optimization problem, ACADO uses some kind of solver.

\subsubsection{KKT-Tolerance}

In order to rate the "goodness" of a solution, ACADO uses some kind of KKT-Tolerance.


\subsection{Nonlinear Model (Working Title)}

Initially, effort was made to implement the nonlinear model presented by Beard \& McLain \cite{uavBEARD} as the prediction model in the optimization problem. This would have given more precise results as the nonlinear model is a closer representation of the real UAV, and since the nonlinear model also includes wind the path could be optimized with the knowledge about the wind conditions as well. The level of calculation needed for the nonlinear model is significantly higher; however, since this implementation is intended to run offline before the flight occurs, computation time is not a critical concern.

Achieving stable flight within in the optimization problem with the nonlinear model on the other hand, turned out to be a difficult task that was far from trivial. This is somewhat due to the nonlinearity, but also the high coupling between states in the model. The coupling causes changes in one state to affect many other states which results in a much more complex problem. Several different algorithm and solver settings was tried, as well as different objective functions and weighting of these functions. After many attempts the decision to use the linear model instead was made, largely due to this being a project with limited time available.